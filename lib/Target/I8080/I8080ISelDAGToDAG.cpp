//===- I8080ISelDAGToDAG.cpp - A DAG pattern matching inst selector for I8080 -===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This file defines a DAG pattern matching instruction selector for I8080,
// converting from a legalized dag to a I8080 dag.
//
//===----------------------------------------------------------------------===//

#include "I8080.h"
#include "I8080Subtarget.h"
#include "I8080TargetMachine.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
using namespace llvm;

#define DEBUG_TYPE "z80-isel"

namespace {
//===--------------------------------------------------------------------===//
/// ISel - I8080-specific code to select I8080 machine instructions for
/// SelectionDAG operations.
///
class I8080DAGToDAGISel final : public SelectionDAGISel {
  /// Keep a pointer to the I8080Subtarget around so that we can
  /// make the right decision when generating code for different targets.
  const I8080Subtarget *Subtarget;

  /// If true, selector should try to optimize for code size instead of
  /// performance.
  bool OptForSize;

public:
  explicit I8080DAGToDAGISel(I8080TargetMachine &TM, CodeGenOpt::Level OptLevel)
    : SelectionDAGISel(TM, OptLevel), OptForSize(false) {}

  StringRef getPassName() const override {
    return "I8080 DAG->DAG Instruction Selection";
  }

  bool runOnMachineFunction(MachineFunction &MF) override {
    // Reset the subtarget each time through.
    Subtarget = &MF.getSubtarget<I8080Subtarget>();
    return SelectionDAGISel::runOnMachineFunction(MF);
  }

// Include the pieces autogenerated from the target description.
#include "I8080GenDAGISel.inc"

private:
  void Select(SDNode *N) override;

  bool SelectMem(SDValue N, SDValue &Mem);
  bool SelectOff(SDValue N, SDValue &Reg, SDValue &Off);
  bool SelectFI(SDValue N, SDValue &Reg, SDValue &Off);

  /// Implement addressing mode selection for inline asm expressions.
  bool SelectInlineAsmMemoryOperand(const SDValue &Op, unsigned ConstraintID,
                                    std::vector<SDValue> &OutOps) override;
};
}

void I8080DAGToDAGISel::Select(SDNode *Node) {
  SDLoc DL(Node);

  // Dump information about the Node being selected
  LLVM_DEBUG(dbgs() << "Selecting: "; Node->dump(CurDAG); dbgs() << '\n');

  // If we have a custom node, we already have selected!
  if (Node->isMachineOpcode()) {
    LLVM_DEBUG(dbgs() << "== "; Node->dump(CurDAG); dbgs() << '\n');
    Node->setNodeId(-1);
    return;
  }

  // Select the default instruction
  SelectCode(Node);
}

bool I8080DAGToDAGISel::SelectMem(SDValue N, SDValue &Mem) {
  switch (N.getOpcode()) {
  default:
    LLVM_DEBUG(dbgs() << "SelectMem: " << N->getOperationName() << '\n');
    return false;
  case ISD::Constant: {
      uint64_t Val = cast<ConstantSDNode>(N)->getSExtValue();
      //Mem = CurDAG->getTargetConstant(Val, SDLoc(N), MVT::i24);
      Mem = CurDAG->getTargetConstant(Val, SDLoc(N), MVT::i16);
      return true;
    }
  case I8080ISD::Wrapper: {
      Mem = N->getOperand(0);
      return true;
    }
  }
}
bool I8080DAGToDAGISel::SelectOff(SDValue N, SDValue &Reg, SDValue &Off) {
  switch (N.getOpcode()) {
  default: return false;
  case ISD::ADD:
    for (int I = 0; I != 2; ++I) {
      if (ConstantSDNode *C = dyn_cast<ConstantSDNode>(N.getOperand(I))) {
        int64_t Val = C->getSExtValue();
        if (!isInt<8>(Val)) {
          continue;
        }
        Reg = N.getOperand(1 - I);
        FrameIndexSDNode *Idx = dyn_cast<FrameIndexSDNode>(Reg);
        if (Val >= -1 && Val <= 1 && !Idx && Reg.hasOneUse()) {
          continue;
        }
        if (Idx)
          Reg = CurDAG->getTargetFrameIndex(
                  Idx->getIndex(), TLI->getPointerTy(CurDAG->getDataLayout()));
        Off = CurDAG->getTargetConstant(Val, SDLoc(N), MVT::i8);
        LLVM_DEBUG(dbgs() << "Selected ADD:\n";
                   N.dumpr();
                   dbgs() << "becomes\n";
                   Reg.dumpr();
                   Off.dumpr());
        return true;
      }
    }
    return false;
  case ISD::FrameIndex:
    Reg = CurDAG->getTargetFrameIndex(
            cast<FrameIndexSDNode>(N)->getIndex(),
            TLI->getPointerTy(CurDAG->getDataLayout()));
    Off = CurDAG->getTargetConstant(0, SDLoc(N), MVT::i8);
    return true;
  }
}
bool I8080DAGToDAGISel::SelectFI(SDValue N, SDValue &Reg, SDValue &Off) {
  if (!SelectOff(N, Reg, Off)) {
    return false;
  }
  return isa<FrameIndexSDNode>(Reg);
}

bool I8080DAGToDAGISel::
SelectInlineAsmMemoryOperand(const SDValue &Op, unsigned ConstraintID,
                             std::vector<SDValue> &OutOps) {
  SDValue Op0, Op1;
  switch (ConstraintID) {
  default:
    llvm_unreachable("Unexpected asm memory constraint");
  case InlineAsm::Constraint_m:
    if (!SelectMem(Op, Op0)) {
      return true;
    }
    OutOps.push_back(Op0);
    return false;
  case InlineAsm::Constraint_o:
    if (!SelectOff(Op, Op0, Op1)) {
      return true;
    }
    OutOps.push_back(Op0);
    OutOps.push_back(Op1);
    return false;
  }
}

/// This pass converts a legalized DAG into I8080-specific DAG,
/// ready for instruction scheduling.
FunctionPass *llvm::createI8080ISelDag(I8080TargetMachine &TM,
                                     CodeGenOpt::Level OptLevel) {
  return new I8080DAGToDAGISel(TM, OptLevel);
}
